### js执行上下文和执行栈
  执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。  
  执行栈用于存储在代码执行期间创建的执行上下文。也叫调用栈，有LIFO先进后出的结构。
  <b>执行上下文在运行时创建, 随时可能改变。</b>
#### 执行上下文类型
* 全局执行上下文: 默认的、最基础的执行上下文。一个程序中有且仅有一个全局执行上下文。
* 函数执行上下文: 每次函数被调用时，就会创建一个新的局部执行上下文。可以存在多个。
* eval函数: 运行在eval函数中的执行上下文

#### 执行上下文包括三个重要属性
* 变量对象(Variable Object / VO): 与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。  
      包括: 函数的所有形参、函数声明和变量声明
* 作用域链(Scope Chain)
* this

#### 执行上下文的周期
* 创建阶段: 创建变量对象、建立作用域链和确定this指向。<b>变量对象不能被访问。</b>
* 执行阶段: 变量赋值和函数引用以及其他代码。<b>变量对象转变为活动对象，里面的对象都可以被访问。</b>

看下面代码
```
console.log(foo); //打印的是函数  

function foo(){
    console.log("foo");
}

var foo = 1;
console.log(foo); // 打印 '1'
```
<b>在同一个函数执行上下文，声明的函数和变量(在创建阶段声明, 变量还未赋值)，且函数优先级比变量高(有相同名称的函数和变量，函数优先级高)，然后执行阶段，第一行代码打印的是函数，
随后foo赋值为1，打印出来1。</b>

### js作用域和作用域链
当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到就会父级执行上下文的变量对象中查找，一直找到全局执行上下文的变量对象，这样由多个执行上下文的变量对象构成的链表叫做作用域链。
作用域最大的作用就是隔离变量，不同作用域下的同名变量不会冲突。  
有全局作用域、函数作用域、块级作用域(如if, for等)和动态作用域。

```
function foo() {
    console.log(value);
}
function bar() {
    value = 2;
    foo();
}
var value = 1;

bar();//2

```
<b>函数的作用域在函数定义的时候就决定了, 并且不会改变。</b>  

### 作用域和执行上下文的区别
  解释阶段：词法分析、语法分析和作用域规则确定
  执行阶段：创建执行上下文、执行函数代码和垃圾回收
  
  执行上下文在运行时确定，随时可能改变；
  作用域在定义时就确定，并且不会改变；
  同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。


### this指向
1. this永远指向一个对象，
2. this指向完全取决于函数的调用位置

```
var obj = {
  foo: function () { console.log(this.bar) },
  bar: 1
};

var foo = obj.foo;
var bar = 2;

obj.foo() // 1
foo() // 2
```
<b>this指向的是最后调用它的对象</b>


### 闭包
引入阮一峰的话就是：<b>闭包就是能够读取其他函数内部变量的函数。</b>
自由变量: 是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
闭包 = 函数 + 函数能够访问的自由变量

```
function greet() {
  let test = 'Hi,';
  function sayHello(name) {
    test += name
    return test;
  }
  return sayHello;

}

let gt = greet();
gt('t1');   // Hi,t1
gt('t2');   // Hi,t1t2
```
上面代码共用同一个变量。

#### 闭包的用途
  由于可以访问其他函数内部变量的特性, 闭包可以用来模拟私有变量;
  但由于其上下文已经销毁, 它仍然存在, 所以不能滥用闭包, 否则会造成性能问题;  






#### 参考
1.https://github.com/mqyqingfeng/Blog/issues/7
2.https://www.ruanyifeng.com/blog/2018/06/javascript-this.html
3.http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html
