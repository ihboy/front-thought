### 深拷贝和浅拷贝
  * 概念   
    +  深拷贝：将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且新对象的修改不会影响原对象；    
    +  浅拷贝：新对象有着原始对象属性值的精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象；    
  
  * 浅拷贝的实现方式    
    +  Object.assign(target, ...sources)函数    
    ```
      var test1 = {
        a: 1,
        b: 'hahaha',
        c: {
          n: 'nihao',
          m: {
            x: 'xxxx'
          }
        }
      }
      var test3 = Object.assign(test1, {b:'test3'}, {d: 'ddddd'}, {a: 5});  // {a: 5, b: "test3", c: {n: "nihao", m: {x: 'xxx'}}, d: "ddddd"}
      test3.c.n = 'hi'
      console.log(test1.c.n);     // hi          
    ```
      源对象上的相同属性会覆盖target的属性。   
      
    + ES6扩展运算符(...)   
      ```
        var test4 = {...test1} 
      ```
      
    + 循环遍历（只遍历最外层）   
      ```
        function clone(obj) {
          if( obj == null || ( typeof obj != 'object' && typeof obj != 'function' ) ) {   // 
            return obj;
          }
          var target = Array.isArray(obj) ? [] : {}
          for(let i in obj) {
            console.log(i, obj[i]);
            target[i] = obj[i];
          }
          return target;
        }
      ```
    
  * 深拷贝的实现方式   
    + JSON.parse(JSON.stringify(obj))     
    + 递归遍历   
      ```
        function deepClone(obj) {
          if( obj && typeof obj === 'object' ) {
            var target = Array.isArray(obj) ? [] : {};
            for( let key in obj ) {
              target[key] = deepClone(obj[key]);
            }
            return target
          }
          return obj;
        }
      ```
      这种方式会存在一个问题：当拷贝一个循环引用对象是，会报"Maximum call stack size exceeded"的问题。
      
      ```
        var A = {};
        A.A = A;
        var B = deepClone(A);
      ```
      所以我们将遍历的对象保存起来，在遍历对象的之前，可以做一个判断，判断对象是否已经存在，存在则返回，不存在则加入到保存的对象中，所以我们可以用Map数据类型来存储，因为Map数据类型可以的key可以用对象表示，代码如下：   
      ```
        function deepClone(obj, map = new Map()) {
          if( obj && typeof obj === 'object' ) {
            var target = Array.isArray(obj) ? [] : {};
            if(map.get(obj)) {   // 如果存在就不再遍历，直接返回
              return map.get(obj)
            }
            map.set(obj, target);
            for( let key in obj ) {
              target[key] = deepClone(obj[key], map);
            }
            return target
          }
          return obj;
        }
      ```
      <b>WeakMap与Map区别:</b>   
        - WeakMap对象是一组键/值对的集合，其中的键是弱引用的,只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏；
        - 其键必须是对象，而值可以是任意的；  
        - 由于WeakMap的成员随时可能被垃圾回收机制回收，成员的数量不稳定；  
        - 没有clear属性；
        - 不能遍历；
      <b>弱引用:</b>    
