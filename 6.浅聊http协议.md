### HTTP协议
  http是超文本传输协议,用来客户端和服务端传递数据; 协议是通信计算机双方必须共同遵从的一组约定。  
#### HTTP特点
  1. 支持客户端/服务端模式: 客户端发送请求,服务端响应数据;
  2. 简单快速: 客户端请求时,只需传送地址和请求方法;常见请求方法: GET、POST、PUT、DELETE、HEAD、OPTIONS等;由于http协议简单,使得http服务器规模小,因而通信速度快;  
  3. 灵活: http允许传输各种类型的数据, 数据类型由Content-Type加以标识; 
  4. 无连接: 每次连接只处理一个请求,处理完成即断开, 这种方式可以节省传输时间;   
  5. 无状态: http协议不保存请求和响应之间的状态; 每个请求都是独立的,前面的请求和后面的请求没有直接联系。  
#### HTTP报文  
  1. 请求报文  
    (1)请求行 <请求方法>   <请求地址>    <协议版本>, 例如: POST  /index.html  HTTP/1.1  
    (2)http首部字段: 请求首部|通用首部|实体首部 
      Host: www.test.com  
      Content-Type: appication/x-www-form-urlencoded、aplication/json  
      Content-length: 9  
      Connection: keep-alive(1.1默认字段)、close(1.0 默认字段)  
      Accept: application/json, text/javascript, \*/\*  
      Accept-Encoding: gzip、deflate、br   
      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36  
    (3)空行 用于分割请求头和请求体  
    (4)请求数据 name=aaa&age=17  
  2. 响应报文  
    (1)响应行 <协议版本>   <状态码>   <描述>, 例如: HTTP/1.1  200   OK  
    (2)http首部字段: 响应首部|通用首部|实体首部   
      Content-Length: 60  
      Content-Type: text/plain; charset=UTF-8  
      Date: Mon, 07 Dec 2020 09:44:12 GMT    
    (3)响应体
    
  3. 首部字段:
    (1)通用首部字段:   
```
    Cache-Control       // 控制缓存行为
    Connection          // 连接的管理
    Date                // 创建报文的日期时间
    Pragma              // 报文指令
    Trailer             // 报文末端的首部一览
    Transfer-Encoding   // 指定报文主体的传输编码方式
    Upgrade             // 升级为其他协议
    Via                 // 代理服务器相关信息
    Warning             // 错误通知
```  
 
    (2)实体首部字段
```
    Allow               // 资源可支持的http方法
    Content-Encoding    // 实体主体适用的编码方式
    Content-Language    // 实体主体的自然语言
    Content-Length      // 实体主体的大小
    Content-Location    // 替代对应资源的uri
    Content-MD5         // 实体主体的报文摘要
    Content-Range       // 实体主体位置范围
    Content-Type        // 实体主体的媒体类型
    Expires             // 实体主体过期时间
    Last-Modified       // 资源的最后修改日期时间
```
    (3)请求首部字段
```
    Accept              // 用户代理可处理的媒体类型
    Accept-Charset      // 优先的字符集
    Accept-Encoding     // 优先的内容编码
    Accept-Language     // 优先的语言
    Authorization       // web认证信息
    Expect              // 期待服务器的特定行为
    From                // 用户的电子邮箱地址
    Host                // 请求资源所在服务器
    If-Match            // 比较实体标记
    If-Modified-Since   // 比较资源的更新时间
    If-None-Match       // 比较实体标记
    If-Range            // 资源未更新时发送实体Byte的范围请求
    If-Unmodified-Since // 比较资源的更新时间
    Max-Forwards        // 最大传输逐跳数
    Proxy-Authorization // 代理服务器要求客户端的认证信息
    Range               // 实体的字节范围请求
    Referer             // 对请求中URI的原始获取方
    TE                  // 传输编码的优先级
    User-Agent          // HTTP客户端程序的信息
```
    (4)响应首部字段  
```
    Accept-Ranges       // 是否接受字节范围请求
    Age                 // 推算资源创建经过的时间
    ETag                // 资源的匹配信息
    Location            // 令客户端重定向至指定URI
    Proxy-Authenticate  // 代理服务器对客户端的认证信息
    Retry-After         // 对再次发起请求的时机要求
    Server              // HTTP服务器的安装信息
    Vary                // 代理服务器缓存的管理信息
    WWW-Authenticate    // 服务器对客户端的认证信息
```   
#### HTTP常见的状态码  
    1XX: 指示信息--表示请求已接收, 继续处理  
    2XX: 成功--请求被成功接收、理解、处理  
        200: ok 请求成功  
        204: no content 请求成功但是没有返回结果  
        206: partial content 部分请求成功  
    3XX: 重定向--要附加操作才能完成请求
        301: move permanently 永久重定向  
        302: found  临时重定向 表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址    
        303: see other  
        304: Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容   
    4XX: 客户端错误--请求有语法错误或请求无法实现
        401: Unauthorized 客户端需要认证   
        403: Forbidden 禁止访问  
        404: Not Found 没找到
        405: Method Not Allowed 请求方法不被允许   
    5XX: 服务器端错误--服务器未能实现合法的请求  
        500: Internal Server Error  服务端执行请求时发生了错误    
        501: Not Implemented  客户端发起的请求超出服务器的能力范围  
        502: Bad Gateway  网关故障  
        503: Service Unavailable  服务器正在超负载或者停机维护，无法处理请求   
#### HTTP 缓存策略  
    1. 强缓存: 如果命中缓存不需要和服务器端发生交互, 强缓存优先级高于协商缓存 
        当浏览器向服务器请求数据时, 服务器端会将数据和缓存规则返回, 在响应头的header中,有Expires和Cache-Control:   
            Expires: Wed, 11 Sep 2019 16:12:18 GMT。返回数据的缓存到期时间戳。当浏览器在进行请求的时候, 会拿本地时间和这个时间做对比, 判断资源是否过期。
                     但是就会有问题, 如果本地时间不正确,就会出现问题, 这也时http1.0的问题。
            Cache-Control: 为了解决上述的问题, http1.1增加了这个字段, 如果两个字段同时存在,就以Cache-Control为主。有以下字段:   
                      max-age=7200: 资源只可以存在7200s,在这个时间段内都可以缓存获取资源   
                      public: 表示可以被任何对象(发送请求的客户端、代理服务器等等)缓存
                      private: 表示只有用户自己的浏览器能够缓存,公共的代理服务器不允许缓存
                      no-store: 表示当前请求资源禁用缓存, 每次请求都要向服务器重新获取数据
                      no-cache: 强制所有缓存了该响应的用户,在使用已缓存的数据前, 发送待验证器的请求到服务器
    2. 协商缓存: 不管是否命中都需要和服务端发生交互
         当强缓存没命中的时候, 浏览器一定回向服务器发起请求。服务端根据Request Header中的一些字段来判断是否命中协商缓存。  
         如果命中, 返回304但不返回任何响应实体;如果没有命中则直接从服务器加载资源。判读是否命中协商缓存的字段:  
             Last-Modified: 资源的最后修改时间。 第一次请求服务器, 服务器的头部字段可增加这个字段, 用于设置协商缓存;  
             If-Modified-Since: 通过上面步骤, 当浏览器再次发起请求的时候, 首部字段增加这个字段值为本地时间戳 发送给服务器;  
             服务端接收到请求之后, 就拿If-Modified-Since字段值和本身的过期事件对比。如果小于最后修改时间,返回304。如果时间过期,在Response Headers中添加新的Last-Modified值返回给浏览器。  
         
         但是通过Last-Modified存在一个局限性:   
              1. 不该请求,还是会请求。编辑文件但是内容没有变化, 但是服务器认为我们改动了文件,所以重新设置缓存时间, 当做新请求返回给浏览器。  
              2. 该请求反而没有请求。修改文件速度很快,快过If-Modified-Since字段时间差的检测,文件虽然改动了, 但并没有重新生成新的资源。
              3. 只能精确到秒。   
              
         ETag: 标识字符串。 由于上述字段存在缺陷, 所以http/1.1添加Etag字段对资源内容编码,只要内容被改变,这个编码就不同。请求原理和上面一样。  
               首次请求服务端返回一个标识字符串, 浏览器再次请求, 携带一个值相同的字符串( <b>If-None-Match</b>字段 ); 服务端接收到该字符串就会作对比, 如果相同就读取本地缓存,否则返回新的资源。   
  
  
