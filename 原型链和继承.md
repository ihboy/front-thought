### 原型链和继承
    每一个函数都有一个prototype属性指向它的原型对象;每一个对象也都有一个__proto__指针指向他们的原型对象;constructor构造函数通过new 创建对象。

```
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  
  let p1 = new Person('ww', '11');
  
  p1.__proto__ == Person.prototype  // true
  
```

#### 原型对象
  构造函数的__proto__都指向Function的原型对象, 包括Function本身;
```
  Number.__proto__ == Function.prototype   //true
  String.__proto__ == Function.prototype   //true
  Boolean.__proto__ == Function.prototype  //true
  Symbol.__proto__ == Function.prototype   //true
  Array.__proto__ == Function.prototype    //true
  Object.__proto__ == Function.prototype   //true
  
  Function.__proto__ == Function.prototype     //true
  
  typeof Function.prototype         // function
  
  Function.prototype.__proto__ == Object.prototype  // true
  
  Object.prototype.__proto__ == null
  
```
  所以 Function 既是函数也是对象; 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身, 所有构造器也都是一个普通 JS 对象;
  Object.prototype是作用域链的顶端, 再往上的原型对象为 null, 所以原型链的终点是 null。
  
#### 原型链
  当要查找一个对象的属性或方法的时候, 如果对象自身没有这个属性或方法,就会沿着原型链往上查找, 直到找到或者至顶点(没有就返回 undefined)。
  
```
  Person.prototype.sayHello = function() { console.log(this.name); }
  p1.sayHello()   // 'ww'
  
  Object.prototype.sayAge = function() { console.log('Hi, ', this.age); }
  p1.sayAge()   // 'hi, 11'
  
  由于 Person.prototype.__proto__ == Object.prototype    // true 
  
```

#### 继承
    


