### 原型链和继承
    每一个函数都有一个prototype属性指向它的原型对象;每一个对象也都有一个__proto__指针指向他们的原型对象;constructor构造函数通过new 创建对象。

```
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  
  let p1 = new Person('ww', '11');
  
  p1.__proto__ == Person.prototype  // true
  
```

#### 原型对象
  构造函数的__proto__都指向Function的原型对象, 包括Function本身;
```
  Number.__proto__ == Function.prototype   //true
  String.__proto__ == Function.prototype   //true
  Boolean.__proto__ == Function.prototype  //true
  Symbol.__proto__ == Function.prototype   //true
  Array.__proto__ == Function.prototype    //true
  Object.__proto__ == Function.prototype   //true
  
  Function.__proto__ == Function.prototype     //true
  
  typeof Function.prototype         // function
  
  Function.prototype.__proto__ == Object.prototype  // true
  
  Object.prototype.__proto__ == null
  
```
  所以 Function 既是函数也是对象; 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身, 所有构造器也都是一个普通 JS 对象;
  Object.prototype是作用域链的顶端, 再往上的原型对象为 null, 所以原型链的终点是 null。
  
#### 原型链
  当要查找一个对象的属性或方法的时候, 如果对象自身没有这个属性或方法,就会沿着原型链往上查找, 直到找到或者至顶点(没有就返回 undefined)。
  
```
  Person.prototype.sayHello = function() { console.log(this.name); }
  p1.sayHello()   // 'ww'
  
  Object.prototype.sayAge = function() { console.log('Hi, ', this.age); }
  p1.sayAge()   // 'hi, 11'
  
  由于 Person.prototype.__proto__ == Object.prototype    // true 
  
```

#### 继承
 1. 原型链继承
    由于原型链, js可以通过作用域链上添加方法或属性来实现继承; 如下代码：
```
  function Student() {}

  Student.prototype.name = 'xiaom'
  Student.prototype.age = '女'
  Student.prototype.study = function() { console.log('学习中'); }

  let sA = new Student();
  let sB = new Student();

  sB.name = 'lili'
  console.log(sA.name);	// 'xiaom'

```
  上面实现有一个缺点, 当原型链上面有一个引用类型的数据时, sB的改动会导致sA也变化。如下所示：
```
  Student.prototype.box = ['b1', 'b2', 'b3'];
  
  sA.box.push('b4');
  sB.box      // ['b1', 'b2', 'b3', 'b4']
```
  原型链继承的时候, 引用类型会被所有对象共享, 导致sA改变, sB也跟着改变。
  为了解决上面问题, 我们可以用 借用构造函数继承 
  
  2. 借用构造函数继承
  
```
  function Parent() {
    this.sayHello = function() {
      console.log('hi, ', this.name);
    }

    this.box = ['b1', 'b2', 'b3'];

  }


  function Child(name) {
    this.name = name;
    Parent.call(this);
  }

  let p1 = new Child('xiaoH');
  let p2 = new Child('xiaoL');
  
  p1.sayHello == p2.sayHello    // false
```
  虽然在子类中通过call 函数，实现了继承,解决了父类中引用类型共享的问题,但是父类中公用的方法在每个对象上重新实现了一边;
